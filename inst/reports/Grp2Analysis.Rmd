---
title: "FGCZ Two-Group Analysis: `r grp2$projectName` \n Statistics for a Quantitative Protein Matrix"
author: "Functional Genomics Center Zurich"
date: "`r format(Sys.time(), '%d %B, %Y')`"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE
)

if(!exists("progress")){
  progress <- function(howmuch, detail){
    invisible(NULL)
  }
}
```

# Input Matrix

Experiment is called: `r grp2$projectName`

## The Numbers

The protein matrix is filtered like this:

- Minimum number of peptides / protein: `r grp2$nrPeptides`
- Maximum of missing values per protein : `r grp2$maxNA`

The total number of proteins in this experiment is: `r nrow(grp2$proteinIntensity)`


# The Groupings


```{r}

library(knitr)
library(qvalue)
library(limma)

tab <- data.frame(table(grp2$getAnnotation()$Condition))
colnames(tab) <- c("Condition","# samples")
knitr::kable(tab)

```

Here the files in each group:

```{r }
tab<-grp2$getAnnotation()[,c("Condition","Raw.file")]
rownames(tab) <- NULL
knitr::kable(tab)

```

\pagebreak




# Proteins Used for Quantitation

```{r histmissing }
missing <- grp2$getNrNAs()
int <- apply(grp2$proteinIntensity,1,sum, na.rm=TRUE)
grp2$proteinIntensity <- grp2$proteinIntensity[order(missing, -int,decreasing = T),]
```

The input matrix has the following structure (Figure \@ref(fig:overview)).

```{r overview, fig.width=8,fig.height=6,dpi=300,fig.cap="Heatmap for quantifyable proteins sorted by missigness and intensity (log2). Gray - missing values"}
library(quantable)
imageWithLabels(t(log2(grp2$proteinIntensity)), col.labels = NULL, col=quantable::getBlueScale(21))
```



```{r missingValuesPerProtein, fig.cap="# of missing values per protein"}
plot(table(missing), xlab="number of missing values", ylab="number of proteins")
progress(0.1, "Summary")

```

\pagebreak

# Distribution of Intensities

Shown in Figure \@ref(fig:distributionRaw) are the distributions of raw log2 transormed intensity values. 

```{r distributionRaw, fig.width=7, fig.height=7, fig.cap="Density plot for quantifyable proteins (log2 transformed)"}
library(ggplot2)
library(reshape2)
longm <- melt(log2(grp2$proteinIntensity))

p <- qplot( variable , value , data=longm , geom="violin" , xlab="" , ylab="log2(I)")
p + stat_summary(fun.y=median,geom='point') +theme(axis.text.x = element_text(angle = 90, hjust = 1))


```

In Figure \@ref(fig:scaling) the ratios of the median intensity in each sample versus the least intensive sample are shown. Large fold changes (greater than 10) are critical. 

```{r  scaling,dpi=300, fig.height=6, fig.cap="Median(I sample) / min(median(I sample)."}
par(mar=c(3,10,3,3))
bb <- 2^grp2$getNormalized()$medians
barplot(bb/min(bb) ,horiz=F,las=2, main="median", cex.names = 0.6)
progress(0.2, "Normalization")

```



# Normalization

Figure \@ref(fig:normalized) shows the $z$ transformed values. After the z-transformation all samples have same median and the same variance.

```{r normalized,  fig.width=7,fig.height=7,dpi=300, fig.cap="Density plot for normalized values (z-score)"}

longm <- melt(grp2$getNormalized()$data)
p <- qplot( variable , value , data=longm , geom="violin" , xlab="" , ylab="z-score")
p + stat_summary(fun.y=median,geom='point') + theme(axis.text.x = element_text(angle = 90, hjust = 1))

```


\pagebreak





# Coefficients of Variations

```{r CViolin, fig.cap="distribution of protein CV within condition and overall"}
cond1 <- grp2$getConditionData(grp2$conditions[1])
cond2 <- grp2$getConditionData(grp2$conditions[2])


cond1 <- quantable::CV(cond1)
cond2 <- quantable::CV(cond2)
all <- quantable::CV(grp2$proteinIntensity)
CVs <- rbind(data.frame(condition=grp2$conditions[1], cv=cond1),
             data.frame(condition=grp2$conditions[2],cv=cond2 ),
             data.frame(condition="all", cv=all))

p <- qplot( condition , cv , data=CVs , geom="violin" , xlab="" , ylab="Coefficient of Variation (%)")
p + stat_summary(fun.y=median,geom='point') + theme(axis.text.x = element_text(angle = 90, hjust = 1))

```


```{r}
cvSummary <- aggregate(cv ~ condition , data=CVs , median, na.rm=TRUE)
knitr::kable(cvSummary,caption = 'median of cv')
```

\pagebreak

```{r SDViolin, fig.cap="Distribution of protein standard deviation (after sample normalization and scaling) within conditions and overall"}
cond1 <- grp2$getNormalizedConditionData( grp2$conditions[1] )
cond2 <- grp2$getNormalizedConditionData( grp2$conditions[2] )

cond1 <- apply(cond1, 1, sd, na.rm=TRUE)
cond2 <- apply(cond2, 1, sd, na.rm=TRUE)

all <- apply( grp2$getNormalized()$data, 1 , sd, na.rm=TRUE )
SDs<-rbind(data.frame( condition=grp2$conditions[1], sd=cond1), data.frame(condition=grp2$conditions[2],sd=cond2 ), data.frame(condition="all", sd=all))

p <- qplot( condition , sd , data=SDs , geom="violin" , xlab="" , ylab="sd of z-score")
p + stat_summary(fun.y=median,geom='point') + theme(axis.text.x = element_text(angle = 90, hjust = 1))

```

```{r}
sdSummary <-aggregate(sd ~ condition , data=SDs , median, na.rm=TRUE)
knitr::kable(sdSummary, caption = 'median of sd')

progress(0.1, "CVs")

```

\pagebreak

# Heatmaps and Clustering for Samples and Proteins

```{r correlation,dpi=300, fig.height=8, fig.width=8, fig.cap="Heatmap of correlations (spearman) between samples."}
col <- c("red","blue")
simpleheatmap(cor(grp2$getNormalized()$data, 
                  use="pairwise.complete.obs", 
                  method="spearman")^2,
                  palette = getGreensScale(21),
                  ColSideColors = col[as.factor(grp2$getAnnotation()$Condition)], 
                  margins = c(10,3))
```

In Figure \@ref(fig:heatmapData) and Figure \@ref(fig:correlation) we show how samples are clustering depending on their correlation and on the protein expression profiles.


```{r heatmapData, fig.width=8, fig.height=10, dpi=300, fig.cap="Heatmap for normalized and scaled values (z-scores)." }
tmp <- grp2$getNormalized()$data

simpleheatmap(grp2$getNormalized()$data[grp2$getNrNAs() < ncol(grp2$getNormalized()$data)/2,],ColSideColors = col[as.factor(grp2$getAnnotation()$Condition)], margins=c(10,3) )

progress(0.2, "Heatmaps")
```


# Two Group Analysis

Here we show the result of a two group analysis for the normalized matrix using the bioconductor limma package. 

```{r include=FALSE}
fixcols <- function(resRel, fcname = "log2(Cond/Cont)", name = "qvalue", top = 20){
  resRel<-do.call("rbind", resRel)
  rownames(resRel) <- NULL
  resRel <- data.frame(resRel,tmp= 2^resRel$foldchange)
  colnames(resRel) <- c("regulation", "Accession", fcname, name, gsub("log2","",fcname))
  
  resRel <- resRel[order(resRel[,name])[1:min(top,nrow(resRel))],]
  
  return(resRel)
}
```

```{r}
progress(0.1, "debug-3")
```

\newpage

## Adjusted moderated p-values (q-values) (limma output)

If the groups are different we would expect more small p-values in Figure \@ref{fig:histOfpValues} than by chance (blue horizontal line). If there are only as many or less small p-values as by chance than no significant false discovery rate controlled calls will be made in Figure \@ref{fig:volcanoplot}. 

```{r}
fcname <- paste("log2(", grp2$getConditions()$condition, "/", grp2$getConditions()$reference, ")", sep="")
progress(0.1, "debug-2")
res.eb <-grp2$getPValues()

```


```{r histOfpValues, fig.width=10, fig.height=8, dpi=300, fig.cap="Histogram of moderated p values."}
hist(res.eb$p.mod, breaks=20, xlab="", main="")
abline(h=length(res.eb$p.mod)/20,col="blue")
abline(v=0.05,col=2)
```

Significant calls are made with q-value smaller than `r grp2$qvalue` (false discovery rate, computed with bioconductor package qvalue) (see Figure \@ref(fig:volcanoplot))


```{r volcanoplot, fig.width=10, fig.height=8, dpi=300, fig.cap="VolcanoPlot for normalized and scaled proteins with stringent thresholds. x axis log2 fold change of z-score"}
resStr <-quantable::volcanoplot(res.eb$log2FC, res.eb$q.mod, foldchangethresh = grp2$qfoldchange , pthresh = grp2$qvalue ,labels=rownames(res.eb),xlab = fcname)
```



\newpage
```{r, eval=FALSE, include=FALSE}
 resRel<-do.call("rbind", resRel)
 head(resRel)
  rownames(resRel) <- NULL
  resRel <- data.frame(resRel,tmp= 2^resRel$foldchange)
  c("regulation", "Accession", fcname, name, gsub("log2","",fcname))
  resRel
  
  colnames(resRel) <- c("regulation", "Accession", fcname, name, gsub("log2","",fcname))
  
  resRel <- resRel[order(resRel[,name])[1:min(top,nrow(resRel))],]
  
  return(resRel)
```

```{r results="markup"}
if(!is.null(resStr)){
  
  head(resStr)
  resRel <- resStr
  resStr<-fixcols(resStr,fcname = fcname, name="moderated qvalue")
  knitr::kable(resStr, caption = "Most significant regulated proteins.")
}
```


\newpage


## Output Data Description

```{r}
knitr::kable(data.frame(columns=colnames(grp2$getResultTable())[1:11]))

```


# References

This report was generated using the package [SRMService](http://github.com/protViz/SRMService) and [quantable](http://github.com/protViz/quantable). The q-values and p-values were computed using the bioconductor package [limma](https://bioconductor.org/packages/release/bioc/html/limma.html) and [qvalue](https://bioconductor.org/packages/release/bioc/html/qvalue.html).

For questions and improvements please do contact the authors of the package [_SRMService_](https://github.com/protViz/SRMService/graphs/contributors).


## Disclaimer and Acknowledgements

This document was generated using Rmarkdown and processes text files which are generated with a label-free quantitation software such as MaxQuant or Progenesis. 
The obtained results should be validated orthogonal as well (e.g. with Western blots). The Functional Genomics Center Zurich does not provide any kind of guarantee of the validity of these results.

\newpage
# Session Info

```{r}
sessionInfo()
```


