---
title: "FGCZ Two-Group Analysis: `r grp2$projectName` \n Statistics for a Quantitative Protein Matrix"
author: "Functional Genomics Center Zurich"
date: "`r format(Sys.time(), '%d %B, %Y')`"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE
)

if(!exists("progress")){
  progress <- function(howmuch, detail){
    invisible(NULL)
  }
}
```

# Input Matrix

Experiment is called: `r grp2$projectName`

## The Numbers

The protein matrix is filtered like this:

- Minimum number of peptides / protein: `r grp2$nrPeptides`
- Maximum of missing values per protein : `r grp2$maxNA`


- The total number of proteins in this experiment is: `r nrow(grp2$proteinIntensity)` 
- Total number without decoys sequences is `r nrow(grp2$proteinIntensity) -  sum(grepl("REV__",grp2$proteinAnnotation$ProteinName))` 


- Percentage of contaminants : `r round(mean(grepl("CON__",grp2$proteinAnnotation$ProteinName)) * 100, digits=1)` %
- Percentage of false postivies : `r round(mean(grepl("REV__",grp2$proteinAnnotation$ProteinName)) * 100, digits=1)` %



## The Groupings


```{r}

library(knitr)
library(qvalue)
library(limma)

tab <- data.frame(table(grp2$getAnnotation()$Condition))
colnames(tab) <- c("Condition","# samples")
knitr::kable(tab)

```

Here the files in each group:

```{r }
tab<-grp2$getAnnotation()[,c("Condition","Raw.file")]
rownames(tab) <- NULL
knitr::kable(tab)

```

\pagebreak




## The Protein Quantities


```{r histmissing }
missing <- grp2$getNrNAs()
int <- apply(grp2$proteinIntensity,1,sum, na.rm=TRUE)
grp2$proteinIntensity <- grp2$proteinIntensity[order(missing, -int,decreasing = T),]
```

The input matrix has the following structure (Figure \@ref(fig:overview)).

```{r overview, fig.width=8,fig.height=8,dpi=300,fig.cap="Heatmap for quantifyable proteins sorted by missigness and intensity (log2). Gray - missing values"}
library(quantable)
imageWithLabels(t(log2(grp2$proteinIntensity)), col.labels = NULL, col=quantable::getBlueScale(21))
```



```{r missingValuesPerProtein, fig.cap="# of missing values per protein"}
plot(table(missing), xlab="number of missing values", ylab="number of proteins")
progress(0.1, "Summary")

```

\pagebreak

# Quality Control

## Distribution of Intensities

Shown in Figure \@ref(fig:distributionRaw) are the distributions of raw log2 transformed intensity values. Ideally the violins should look very similar.

```{r distributionRaw, fig.width=7, fig.height=7, fig.cap="Density plot for quantifyable proteins (log2 transformed)"}
library(ggplot2)
library(reshape2)
longm <- melt(log2(grp2$proteinIntensity))

p <- qplot( variable , value , data=longm , geom="violin" , xlab="" , ylab="log2(I)")
p + stat_summary(fun.y=median,geom='point') +theme(axis.text.x = element_text(angle = 90, hjust = 1))

```

In Figure \@ref(fig:scaling) the log2 fold change of the average sample intensity versus the mean average intensity of all samples is shown. It is critical if a samples average deviates more than 5 times from the average of all samples.

```{r  scaling,dpi=300, fig.height=6, fig.cap="Average intensity in sample vs average intensity in all samples. red line - critical fold change."}
bb <- grp2$getNormalized()$medians

par(mar=c(15,6,3,6))
barplot(sort(abs(bb))  - mean(bb) ,horiz=F,las=2, main="median", cex.names = 0.6, ylab="log2(sample average) - log2(total average)", ylim=c(-log2(8),log2(8)))
abline(h=c(-log2(5),log2(5)),col=2)
x<-seq(-3,3,by=1)
axis(4,x,round(2^abs(x),digits=1))
mtext("linear scale", side=4, line=2)
progress(0.2, "Normalization")

```

## Normalization

Figure \@ref(fig:normalized) shows the normalized values. Normalization is applied to remove systematic differences in protein abundance due to different sample concentrations, so that differentially expressed proteins can be detected. To this task the z-score of the log2 transformed intensities is computed, which in addition is multiplied by the average of the standard deviation of the log2 transformed intensities in all samples. After normalization all samples have a similar distribution.


```{r normalized,  fig.width=7,fig.height=7,dpi=300, fig.cap="Density plot for normalized values (z-score)"}
longm <- melt(grp2$getNormalized()$data)
p <- qplot( variable , value , data=longm , geom="violin" , xlab="" , ylab="z-score")
p + stat_summary(fun.y=median, geom='point') + theme(axis.text.x = element_text(angle = 90, hjust = 1))
```

\pagebreak

## Coefficients of Variations


The Figure \@ref(fig:CViolin) show the coefficient of variations for all proteins in each condition and overall. To observe differences between conditions the variation within a condition should be smaller than within all conditions.


```{r CViolin, fig.cap="Distribution of protein CV within condition and overall"}
cond1 <- grp2$getConditionData(grp2$conditions[1])
cond2 <- grp2$getConditionData(grp2$conditions[2])


cond1 <- quantable::CV(cond1)
cond2 <- quantable::CV(cond2)
all <- quantable::CV(grp2$proteinIntensity)
CVs <- rbind(data.frame(condition=grp2$conditions[1], cv=cond1),
             data.frame(condition=grp2$conditions[2],cv=cond2 ),
             data.frame(condition="all", cv=all))

p <- qplot( condition , cv , data=CVs , geom="violin" , xlab="" , ylab="Coefficient of Variation (%)")
p + stat_summary(fun.y=median,geom='point') + theme(axis.text.x = element_text(angle = 90, hjust = 1))

```


```{r}
cvSummary <- aggregate(cv ~ condition , data=CVs , median, na.rm=TRUE)
knitr::kable(cvSummary,caption = 'median of cv')
```

\pagebreak

The Figure \@ref(fig:SDViolin) shows the distributions of standard deviations for all proteins with the conditions and overall after transforming and normalization the data. To observe differences between conditions the standard deviation within a condition should be smaller than within all conditions.  

```{r SDViolin, fig.cap="Distribution of protein standard deviation (after sample normalization and scaling) within conditions and overall"}
cond1 <- grp2$getNormalizedConditionData( grp2$conditions[1] )
cond2 <- grp2$getNormalizedConditionData( grp2$conditions[2] )

cond1 <- apply(cond1, 1, sd, na.rm=TRUE)
cond2 <- apply(cond2, 1, sd, na.rm=TRUE)

all <- apply( grp2$getNormalized()$data, 1 , sd, na.rm=TRUE )
SDs<-rbind(data.frame( condition=grp2$conditions[1], sd=cond1), data.frame(condition=grp2$conditions[2],sd=cond2 ), data.frame(condition="all", sd=all))

p <- qplot( condition , sd , data=SDs , geom="violin" , xlab="" , ylab="sd of z-score")
p + stat_summary(fun.y=median,geom='point') + theme(axis.text.x = element_text(angle = 90, hjust = 1))

```

```{r}
sdSummary <-aggregate(sd ~ condition , data=SDs , median, na.rm=TRUE)
knitr::kable(sdSummary, caption = 'median of sd')

progress(0.1, "CVs")

```

\pagebreak

## Heatmaps and Clustering for Samples and Proteins

```{r correlation,dpi=300, fig.height=8, fig.width=8, fig.cap="Heatmap of correlations (spearman) between samples."}
col <- c("red","blue")
simpleheatmap(cor(grp2$getNormalized()$data, 
                  use="pairwise.complete.obs", 
                  method="spearman")^2,
                  palette = getGreensScale(21),
                  ColSideColors = col[as.factor(grp2$getAnnotation()$Condition)], 
                  margins = c(10,3))
```

In Figure \@ref(fig:correlation) and Figure \@ref(fig:heatmapData) we show how samples are clustering depending on their correlation and on the protein expression profiles.


```{r heatmapData, fig.width=8, fig.height=10, dpi=300, fig.cap="Heatmap of normalized data." }
tmp <- grp2$getNormalized()$data
stmMm <- grp2$getNormalized()$data[grp2$getNrNAs() < ncol(grp2$getNormalized()$data)/2,]
simpleheatmap(t(scale(t(stmMm),scale = F)),ColSideColors = col[as.factor(grp2$getAnnotation()$Condition)], margins=c(10,3),
              breaks=seq(-2.5,2.5,length=26),palette = getBlueWhiteRed(25))
progress(0.2, "Heatmaps")

```

\pagebreak


# Two Group Analysis

In the following analysis we assume that most of the proteins are not regulated (fold change is equal zero). p-values and Q-values are a measure of how likely it is to observe the data given the assumption that they are not differentially regulated. Small p-values tell us that $H_0$ (no regulation) is very unlikely. Figure \@ref(fig:densityOFFoldChanges) shows the distribution of fold changes. Most of the fold changes should be close to zero and also the median of all fold changes (red dashed line) should be close to zero (green line).



```{r}
progress(0.1, "debug-3")
```


```{r}
fcname <- paste("log2(", grp2$getConditions()$condition, "/", grp2$getConditions()$reference, ")", sep="")
progress(0.1, "debug-2")
res.eb <-grp2$getPValues()
```


```{r densityOFFoldChanges, fig.width=10, fig.height=8, dpi=300, fig.cap = "Distribution of log2(FC). red dashed line - median fold change."}
plot(density(na.omit(res.eb$effectSize)), main="")
abline(v=0,col="green")
abline(v=median(res.eb$effectSize),col=2,lty=2)
```


\newpage

## Adjusted moderated p-values (q-values) (limma output)

If the groups are different we would expect more small p-values in Figure \@ref(fig:histOfpValues) than by chance (blue horizontal line). If there are only as many or less small p-values as by chance than no significant false discovery rate controlled calls (Q Values) will be made in Figure \@ref(fig:volcanoplot). 


```{r histOfpValues, fig.width=10, fig.height=8, dpi=300, fig.cap="Histogram of moderated p values."}
hist(res.eb$p.mod, breaks=20, xlab="", main="")
abline(h=length(res.eb$p.mod)/20,col="blue")
```


Significant calls are made with q-value smaller than `r grp2$qvalue` (false discovery rate, computed with bioconductor package qvalue) (see Figure \@ref(fig:volcanoplot))


```{r volcanoplot, fig.width=10, fig.height=8, dpi=300, fig.cap="VolcanoPlot : x axis log2 fold change of normalized data, y axis -log10(Q-value)."}

quantable::volcano2G(res.eb$log2FC,
                     res.eb$q.mod,
                     rownames(res.eb),
                     ylab="-log10(Q Value)",
                     log2FCThresh=grp2$qfoldchange,
                     pthresh=grp2$qvalue
                     ,ylim=c(0,-log10(min(res.eb$q.mod))),size=2)


```


\newpage


```{r results="markup"}
tmp <- grp2$getResultTable()
x <- data.frame(table(tmp$effectSize < grp2$qfoldchange & tmp$q.mod < grp2$qvalue))
if(length(x$Var1) == 2){
 x$Var1 <- c("Not Significant" , "Significant")
}
knitr::kable(x, caption = "Nr of not significant and significant proteins.")
```



```{r top20table}
library(dplyr)
top20 <- tmp %>% dplyr::select( TopProteinName,effectSize, q.mod ) %>% arrange((q.mod) ) %>% head(20)
knitr::kable(top20, caption = "Top 20 proteins by smallest Q Value.")
```



\newpage


## Output Data Description

```{r}
knitr::kable(data.frame(columns=colnames(grp2$getResultTable())[1:11]))

```


# References

This report was generated using the package [SRMService](http://github.com/protViz/SRMService) and [quantable](http://github.com/protViz/quantable). The q-values and p-values were computed using the bioconductor package [limma](https://bioconductor.org/packages/release/bioc/html/limma.html) and [qvalue](https://bioconductor.org/packages/release/bioc/html/qvalue.html).

For questions and improvements please do contact the authors of the package [_SRMService_](https://github.com/protViz/SRMService/graphs/contributors).


## Disclaimer

This document was generated using Rmarkdown and processes text files which are generated with a label-free quantitation software such as MaxQuant or Progenesis. 
The obtained results should be validated orthogonal as well (e.g. with Western blots). The Functional Genomics Center Zurich does not provide any kind of guarantee of the validity of these results.

\newpage
# Session Info

```{r}
sessionInfo()
```


