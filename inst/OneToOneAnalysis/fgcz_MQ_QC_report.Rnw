%% cd MQ_txt_directory && R -e "library(SRMService); SRMService::fgcz_render_One2OneReport()" 
\pdfminorversion=4
%\documentclass[a4paper]{article}
\documentclass[a4paper,DIV19]{scrartcl}

\usepackage{a4wide}
\usepackage[utf8]{inputenc}
\usepackage{lastpage}
\usepackage{fancyhdr}
\usepackage[section]{placeins}
\usepackage{hyperref}
\usepackage{graphics}
\usepackage{rotating}
\pagestyle{fancy}
\cfoot{\thepage\ of \pageref{LastPage}}



<<loadingLibrarys, echo=FALSE, result=HIDE>>=
library(lattice)
library(xtable)
library(gplots)
library(affy)
library(missForest)
library(yaml);
@

<<loadYAML, echo=FALSE, result=HIDE>>=
idx <- grep("WU.*yaml", lf<-list.files("../")); 
Y <- yaml.load_file(file.path("..", lf[idx[1]]))
txt <- Y$application$input[[1]][[1]]
projectID <<- regmatches(txt,regexpr("p[0-9]+",txt))
workunitID <<- Y$job_configuration$workunit_id
@

\graphicspath{{/usr/local/lib/R/site-library/SRMService/samples/images/}{.}}

\begin{document}
\SweaveOpts{concordance=TRUE}


\title{FGCZ \Sexpr{projectID} WU\Sexpr{workunitID}: QC analysis for sample preparation and LC-MS}


\maketitle


\section{Workflow Overview}

The general FGCZ LFQ workflow is described in Figure \ref{fig:workflowOverview}. Briefly:
proteins are precipitated using cold acetone, digested with trypsin and analysed via LC-MS/MS using high-end MS systems (e.g. Q-Exactive). The acquired raw files are processed using MaxQuant. The resulting text files are parsed and further processed to extract critical information on sample preparation and LC-MS performances (e.g. number of missed cleavages, correlation plots, protein identifications, quantitative values, ...).

\begin{figure}[!htb]
  \centerline{\includegraphics[width=0.8\textwidth]{LFQ_QC_workflow.pdf}}
  \caption{Shown is the overview over the workflow how the following results are generated}
  \label{fig:workflowOverview}
\end{figure}


\pagebreak

\section{Summary Overview}
\vspace{0.5cm}
Based on some hard criterias, we evaluate if the quality control step (QC one) is passed or not.
Imporant criterias are outlined below along with a reference to the figure later in the report and a flag if it needs to be evaluated in more depth or not. The criterias are sorted according to their relevancy.
\vspace{1cm}

<<GenerateSummaryTableAndGetQCpassedOrNot, echo=FALSE, results=hide>>=
# BUILD UP SUMMARY TABLE WITH STATIC INFORMATION
qc_summary_table <- matrix(nrow=0, ncol = 5)
colnames(qc_summary_table) <-  c("Criteria", "Reference","Threshold", "Value", "Flag")

diffExpGenes <- c("Max % of regulated proteins (1): ","n/a", "5%", "NA", "NA")
minRsquare <- c("Min R-square for correlation: ","Fig. 15", "0.9", "NA", "NA")
maxScaleFactor <- c("Max scaling factor: ","Fig. 14", "3", "NA", "NA")
varianceMSMS <- c("Difference of identified peptides in biochemical reps: ","Table 2", "30%", "NA", "NA")
percSingleProteinHits <- c("Max % of single hit proteins (in full exp) (2): ","n/a", "50%", "NA", "NA")
#percSingleProteinHitsInQuant <- c("% of single hit proteins in LFQ (2): ","n/a", "0%", "NA", "NA")
missedCleavage <- c("Min % of fully tryptic: ","Fig. 7", "50%", "NA", "NA")
unmodifiedPerc <- c("Min % of unmodified peptides: ","Fig. 8", "80%", "NA", "NA")


qc_summary_table <- rbind(qc_summary_table, diffExpGenes, minRsquare, maxScaleFactor,
                          missedCleavage, unmodifiedPerc, varianceMSMS, percSingleProteinHits)

overall_minimumOKs <- 5
#FillDefault Thresholds
fixDiffExpTreshold <- 5
minRsquare <- 0.9
minScaleFactor <- 3
minVarOfID <- 30
minSingleProteinHits <- 30
minQuantSingleProteinHits <- 0
minMissedCleaveage <- 50
minUnmodPeptides <- 80


qc_summary_table[1,3] <- paste(fixDiffExpTreshold,"%",sep="")
qc_summary_table[2,3] <- minRsquare
qc_summary_table[3,3] <- minScaleFactor
qc_summary_table[4,3] <- paste(minMissedCleaveage,"%",sep="")
qc_summary_table[5,3] <- paste(minUnmodPeptides,"%",sep="")
qc_summary_table[6,3] <- paste(minVarOfID,"%",sep="")
qc_summary_table[7,3] <- paste(minSingleProteinHits,"%",sep="")
#qc_summary_table[8,3] <- paste(minQuantSingleProteinHits,"%",sep="")

#Parse and run for Values
#Differentially Expressed Genes < 0.05
# FoldChangeTh
FCth <- 1.5
sigThr <- 0.05

# apply quant filter
bool_moreThanOnePeptide <- mq_proteinGroups$Razor...unique.peptides > 1
qc_intensities <- mq_proteinGroups_intensities[bool_moreThanOnePeptide,]



if(FALSE){
  message("impute all rows containing values with 0 ...")
  qc_intensities <- SRMService:::ImputeValuesInProtMatrixForRowsWithZeros(qc_intensities)
}else {
  message("remove all rows containing values with 0.")
  qc_intensities[qc_intensities == 0] <- NA
  qc_intensities <- na.omit(qc_intensities)
}


# TODO(jg): refactor function to not output the file
qc_normalized_intensities <- SRMService:::NormalizeWithMedianPQMatrix(qc_intensities)
sf <- "appliedScaleFactors_Median.txt"
scaleF <- read.table(sf, sep=" ", header=F)


# TODO(cp): rename the shit

qc_list_of_significants <- SRMService:::Do2grpTtestRobustOnMatrixAndBHcorrWithThresholdAndFoldChangeAndReturnOnlySignificantsInternalTrafo(ProtQuantMatrix = qc_normalized_intensities,
    SignificanceThreshold = sigThr,
    LinFoldChangeThreshold = FCth,
    bool_TrafoHere = TRUE)

(percDiffExp <- round(100 * nrow(qc_list_of_significants) / nrow(qc_normalized_intensities), 2))
qc_summary_table[1,4] <- percDiffExp

OkOrNot <- "NA"
if(percDiffExp > fixDiffExpTreshold) OkOrNot <- "NOT OK" else OkOrNot <- "OK"
qc_summary_table[1,5] <- OkOrNot

#min R-Square
ProtcorrMatrix <- cor(as.matrix(qc_normalized_intensities))
rsqMin <- min(ProtcorrMatrix)
qc_summary_table[2,4] <- paste(round(rsqMin,4),sep="")
if(rsqMin > minRsquare) OkOrNot <- "OK" else OkOrNot <- "NOT OK"
qc_summary_table[2,5] <- OkOrNot

#ScalingFactor
mxScF <- max(scaleF[,2])
qc_summary_table[3,4] <- round(mxScF,2)
if(mxScF > minScaleFactor) OkOrNot <- "NOT OK" else OkOrNot <- "OK"
qc_summary_table[3,5] <- OkOrNot


#maxVar of Identifed sequences
NumRows <- nrow(mq_summary) / 2
mqPeptideSequencesIdentified <- mq_summary[2:NumRows,34]
percDiffOfPepSeqsID <- 100 - round(100*min(as.numeric(as.character(mqPeptideSequencesIdentified)))/max(as.numeric(as.character(mqPeptideSequencesIdentified))),2)
qc_summary_table[6,4] <-  paste(percDiffOfPepSeqsID,"%",sep="")
if(percDiffOfPepSeqsID > minVarOfID) OkOrNot <- "NOT OK" else OkOrNot <- "OK"
qc_summary_table[6,5] <- OkOrNot



#max % on singleHitProteins
totProteins <- nrow(mq_proteinGroups)
min2peps <- sum(mq_proteinGroups$Razor...unique.peptides > 1)
percMin2Peps <- 100 * (totProteins - min2peps) / totProteins
qc_summary_table[7,4] <- paste(round(percMin2Peps,2),"%",sep="")
if(percMin2Peps < minSingleProteinHits) OkOrNot <- "OK" else OkOrNot <- "Problematic"
qc_summary_table[7,5] <- OkOrNot


#max % on QUANT:singleHitProteins
# totQuantProteins <- nrow(quantDat)
# totSingleHitQuant <- sum(Fulldat[bool_moreThanOnePeptide,]$Razor...unique.peptides == 1)
# percQuantSingleHits <- round(100*totSingleHitQuant/totQuantProteins, 2)
# qc_summary_table[8,4] <- paste(percQuantSingleHits,"%",sep="")
# if(percQuantSingleHits == minQuantSingleProteinHits) OkOrNot <- "OK" else OkOrNot <- "NOT OK"
# qc_summary_table[8,5] <- OkOrNot

#max % on missed cleaves
qc_missedCleave_table <- table(mq_msms$Missed.cleavages, mq_msms$Raw.file)

assignedPepsPerRaw <- vector()
for (i in 1:ncol(qc_missedCleave_table)) {
  assignedPepsPerRaw[i] <- sum(qc_missedCleave_table[,i])
}
assignedZeroMCperRaw <- qc_missedCleave_table[1,]
percMCZero <- round(100*assignedZeroMCperRaw/assignedPepsPerRaw,2)
(minPercMCZero <- min(percMCZero))
qc_summary_table[4,4] <- paste(round(minPercMCZero,2),"%",sep="")
if(minPercMCZero > minMissedCleaveage) OkOrNot <- "OK" else OkOrNot <- "NOT OK"
(qc_summary_table[4,5] <- OkOrNot)

#max % on var mods
#histogram(~ mq_msms$Modifications|mq_msms$Raw.file, main="VarMods per RawFile",  scales = list(x = list(rot = 90, cex=0.8)), par.strip.text = list(cex = 1.2), xlab="Variable modifications")
varModTable <- table(mq_msms$Modifications, mq_msms$Raw.file)
#CRITICAL:: if one changes varMods for searching.. eventually "unmodified" is not last element anymore (alphabetically order, therefore pretty unlikely.. there is only V,W,X,Y,Z left )
unmodifiedRow <- nrow(varModTable)
unmodifiedPerRawFile <- varModTable[unmodifiedRow,]
assignmentsPerRawFile <- vector()
for (i in 1:ncol(varModTable)) {
  assignmentsPerRawFile[i] <- sum(varModTable[,i])
}
percUnmodifiedPerRawFile <- round(100*unmodifiedPerRawFile/assignmentsPerRawFile,2)
qc_summary_table[5,4] <- paste(min(percUnmodifiedPerRawFile),"%",sep="")
if(min(percUnmodifiedPerRawFile) > minUnmodPeptides) OkOrNot <- "OK" else OkOrNot <- "NOT OK"
(qc_summary_table[5,5] <- OkOrNot)

#Baustelle figure out which one is the OK -> build it up different
# jonas (20150601): solved by looking how many TRUE FALSE (at least one TRUE) # crashes if NOT a single OK -> also this is fixed (with quite a hack)
#Table contains 40 cells.. check which ones are OK but then look for FALSE <= 35
acceptableNotOKsInTable <- 40 - overall_minimumOKs
if (table(qc_summary_table=="OK")[1] <= acceptableNotOKsInTable) QC_yn <- "QC passed" else QC_yn <- "QC failed"
(QC_yn <- "QC passed")
@


<<printQCTable, echo=FALSE, results=tex>>=
print(xtable(qc_summary_table,
      caption = "Quality Control Summary, (1) Fold change threshold: 1.5, pValue threshold: 0.05 this is the percentage of false positives. As this is a QC analysis which consists of biochemical replicas where we do not expect to see real changes. (2) single hit proteins are proteins identified with only one peptide. This percentage can vary extensively and is largely sample dependent. Since we are going to quantify proteins with at least 2 peptides this shows the percentage one may loose for quantitation."),
      include.rownames = FALSE,
      scalebox= "0.8"
      )
@


\vspace{1cm}
The QC result is the following:

\vspace{1cm}
\begin{center}
{\LARGE  \textbf{\Sexpr{QC_yn}}}
\end{center}
\pagebreak



\section{Data Input and Output Overview}

\subsection{Input: Samples analysed}
Here the list of acquired raw-files:
<<filenameOverViewTable, echo=FALSE, results=tex>>=
NumFiles <- (nrow(mq_summary)) / 2
files <- mq_summary[2:NumFiles,1]
#myFileIndex <- 1:(NumFiles-1)
betterNames <- gsub(pattern = "^[[:digit:]]+_", replacement = "", gsub(pattern = "Intensity.", replacement = "", files))
evenBetterNames <- gsub(pattern = "^[[:digit:]]+_", replacement = "", gsub(pattern = "^[[:digit:]]+_", replacement = "", betterNames))
myFileTable <- as.matrix(cbind(as.character(files), evenBetterNames))
colnames(myFileTable) <- c("original RawFileNames", "Short Names")
print(xtable(myFileTable, caption="measured files"),
  size="\\normalsize",
  include.colnames = TRUE,
  scalebox= "0.8")
@


\pagebreak

\subsection{Parameters}


The protein identification and QC quantification was performed using MaxQuant.
Below are reported information about the MaxQuant version, the variable modifications taken into consideration, the database used and the targeted False Discovery Rate (FDR) at the spectrum (psm) and protein level. For the complete list of parameters please check the parameters txt file.\\


<<printMQversionInfo, echo=FALSE>>=
#ParametersFile

#write out:
mqVersion <- paste(" ", mq_parameters[1, 2] ,sep="")
decoyMode <- mq_parameters[35,2]
psmFDR <- mq_parameters[6,2]
protFDR <- mq_parameters[11,2]
varMods <- mq_parameters[23,2]
fasta <- mq_parameters[34,2]
enz <- unique(mq_summary[2,3])
enzSpez <- unique(mq_summary[2,4])
@

\begin{verbatim}
MaxQuant version:  \Sexpr{mqVersion}

FASTA: \Sexpr{fasta}
Decoy mode: \Sexpr{decoyMode}
Enzyme: \Sexpr{enz}
Enzyme specificity: \Sexpr{enzSpez}

Protein FDR: \Sexpr{protFDR}
PSM FDR: \Sexpr{psmFDR}

Variable modifications: \Sexpr{varMods}
\end{verbatim}


\subsection{Overview of the data quality}
Information on the LC MS/MS data acquired for each sample:
\begin{itemize}
\item number of MS scans,
\item number MS/MS scans,
\item number of peptide sequences identified.
\end{itemize}

Data are extracted from file \texttt{Summary.txt}.

<<generateIdentTable, echo=FALSE>>=
NumRows <- nrow(mq_summary)/2
# select here what we should from the summary table.. it is too big and too complicated as is
# betterheader <- c("Raw file (short)", "MS_1", "MS/MS", "MS/MS identified", "Peptides identified")
# we only want: names (1), num MS1 (19), num MS2 (20), MSMS identified (30), peptides ident (34)
tt <- cbind(as.character(mq_summary[1:NumRows,1]),as.character(mq_summary[1:NumRows,19]),as.character(mq_summary[1:NumRows,20]),as.character(mq_summary[1:NumRows,30]),as.character(mq_summary[1:NumRows,34]))

topTable <- as.table(tt[-1,])
filesHereInTable <- topTable[,1]
betterfilesHereInTable <- gsub(pattern = "^[[:digit:]]+_[[:alpha:]]+", replacement = "", gsub(pattern = "^[[:digit:]]+_", replacement = "", x = filesHereInTable))
topTable[,1] <- betterfilesHereInTable
# modify header
betterheader <- c("Raw file (short)", "# MS_1", "# MS_2", "(%) MS/MS identified", "# peptide sequences identified")
colnames(topTable) <- betterheader
@


<<printIdentTable, echo=FALSE, results=tex>>=
print(xtable(topTable, caption="Overview on the assingment rates for each file"),
  scalebox= "0.7",
  size="\\small")

@
\pagebreak

\subsection{Protein identifications overview}
Next an overview about the number of proteinGroups is shown. We present here more information about the sequence coverage and how many peptides are identified.


<<GetProteinNumbers, echo=FALSE>>=
NumPep <- nrow(mq_peptides)
N <- nrow(mq_proteinGroups)
bool_OneHitWonder <- mq_proteinGroups$Razor...unique.peptides==1
bool_min2 <- mq_proteinGroups$Razor...unique.peptides>1
bool_min3 <- mq_proteinGroups$Razor...unique.peptides>2
ProtMin2 <- sum(bool_min2)
ProtMin3 <- sum(bool_min3)
averagePepPerProt <- round(mean(mq_proteinGroups$Razor...unique.peptides),2)
medianPepPerProt <- median(mq_proteinGroups$Razor...unique.peptides)
OneHitWonders <- sum(bool_OneHitWonder)
@

\begin{verbatim}
Total number of identified proteins:  \Sexpr{N}
Total number of protein only one single peptide:  \Sexpr{OneHitWonders}
Total number of protein with at least 2 peptides:  \Sexpr{ProtMin2}
Total number of protein with at least 3 peptides:  \Sexpr{ProtMin3}

Average number of peptides per protein:  \Sexpr{averagePepPerProt}
Median number of peptides per protein:  \Sexpr{medianPepPerProt}

Total number of unique identified peptides:  \Sexpr{NumPep}
\end{verbatim}


\subsection{Identified Peptide Sequences}
In the Maxquant output (evidence.txt) file there are informations for all identified peptides in the full experiment. In the Maxquant output (msms.txt) file there are informations for each and every identfied msms scan. We try here to show if all the files have been equally treated (e.g. same digestion efficiency, variable modifications..) \\

Shown is the distribution of picked and fragmented precursor masses for the different input files.

\begin{figure}[!htb]
<<precursorOverViewHistograms, echo=FALSE,fig=TRUE,width=12, height=8>>=
# handle again file names
mq_evidence$Raw.file <- gsub(pattern = "^[[:digit:]]+_", replacement = "", x = mq_evidence$Raw.file)
histogram(~ mq_evidence$m.z|mq_evidence$Raw.file, par.strip.text = list(cex = 1.2), xlab="precursors (m/z)", ylab="Perent of Total (%)")
@
  \caption{Distribution of the precursor m/z of the identified peptides}
  \label{fig:mzID}
\end{figure}

\begin{figure}
<<recalibrationHistogram, echo=FALSE,fig=TRUE,width=12, height=8>>=
histogram(~ mq_evidence$Mass.error..ppm. | mq_evidence$Raw.file,
          nbins = 50,
          main = "Distribution of recalibrated mass error (ppm)",
          par.strip.text = list(cex = 1.2), xlab="Recalibrated mass error (ppm)")
@
  \caption{Distribution of recalibrated mass error (ppm) of precursors. Recalibration is a feature of MaxQuant.}
  \label{fig:ppmErrorCali}
\end{figure}

\pagebreak




<<getNumberOfRawFiles, echo=FALSE>>=
# handle again file names
mq_msms$Raw.file <- gsub(pattern = "^[[:digit:]]+_", replacement = "", x = mq_msms$Raw.file)
N <- length(table(mq_msms$Raw.file))
@


\begin{figure}[!htb]
<<missedCleavagesHistogram, echo=FALSE,fig=TRUE,width=12, height=8>>=
# Here Paolo requested a different plot -> I disagree and leave the trellis bar plot
histogram(~ mq_msms$Missed.cleavages | mq_msms$Raw.file,
          main="Distribution of missed cleavages",
          par.strip.text = list(cex = 1.2), xlab="Number of missed cleavages")
@
  \caption{Overview for missed-cleavages for identified peptides}
  \label{fig:mmc}
\end{figure}

\begin{figure}[!htb]
<<variableModificationHistogram, echo=FALSE,fig=TRUE, width=12, height=15>>=
histogram(~ mq_msms$Modifications | mq_msms$Raw.file,
          ylim = c(0,30),
          main="VarMods per RawFile",
          scales = list(x = list(rot = 90, cex=0.8)),
          par.strip.text = list(cex = 1.2), xlab="Variable modifications")
@
  \caption{Overview of identified modifications for identified peptides (y-axis is truncated at 30 percent)}
  \label{fig:Varmods}
\end{figure}

\begin{figure}[!htb]
<<chargeStateHistogram, echo=FALSE,fig=TRUE,width=12>>=
#Charge
histogram(~ mq_msms$Charge|mq_msms$Raw.file,
          main="Distribution of Charges for identified peptides",
          par.strip.text = list(cex = 1.2), xlab="Charge of identified peptides")
@
  \caption{Overview of charge states for identified peptides. Note: Singly charged peptides are excluded for MS/MS. }
  \label{fig:Charge}
\end{figure}




%
%
%    HERE TO INSERT THE iRT SECTION ON LC STABILTY
%
%

\vspace{5cm}
\pagebreak


\section{QC of Quantitative Values}
\vspace{0.5cm}
<<CalculateNumbersForQuantifyableProteins, echo=FALSE>>=

mq_quantableProteins <- nrow(qc_intensities)
#write out:
totProteins <- nrow(mq_proteinGroups)
msRuns <- ncol(qc_intensities)
grpSize <- ncol(qc_intensities)/2
matWoZeros <- nrow(qc_intensities)
protsWithZeros <- totProteins - matWoZeros
protWihtOnlyOne <- totProteins - mq_quantableProteins
percQuant <- round((mq_quantableProteins*100)/totProteins,2)

colnames(qc_normalized_intensities) <- gsub(x = names(qc_normalized_intensities), pattern = "Intensity.\\d+_", replacement = "")
colnames(qc_intensities) <- gsub(x = names(qc_intensities), pattern = "Intensity.\\d+_", replacement = "")

@

\begin{verbatim}
Total number of proteins (MaxQuant, protFDR=5%) here is:  \Sexpr{totProteins}
--
Number of LC-MS/MS experiments included:  \Sexpr{msRuns}
--
Number of proteins with missing values:  \Sexpr{protsWithZeros}
Number of proteins without missing values: \Sexpr{matWoZeros}

Number of proteins with only one peptide: \Sexpr{protWihtOnlyOne}
Number of quantifiable proteins with more than ONE peptide: \Sexpr{mq_quantableProteins}

\end{verbatim}

\vspace{1cm}
This quality control of quantitative values section should show in the following figures, how the quantitative values for all the samples are distributed, correlated, imputed and normalized. To show the reproducibility among the different protein extracts we do a correlation of all quantitative values (pairwise) (see \ref{fig:normCorr}). The closer the correlation to ONE the better.


The input matrix has the following structure.\\
\begin{figure}[!htb]
<<HeatMapOfQuantableProteins, echo=FALSE, fig=TRUE, width=6, height=10, results=hide>>=
heatmap.2(asinh(as.matrix(qc_intensities)), dendrogram = "none", trace = "none", labRow="",margins=c(20,2), main="Heatmap of quantitative value\r in all experiments", ylab="proteins")
@
  \caption{Heatmap for all proteins with minimum two peptides (= quantifiable proteins) (Intensity value is hyperbolic arcsine transformed)}
  \label{fig:imagPlot}
\end{figure}




\begin{figure}[!htb]
<<plotDensityNoTransformation, echo=FALSE, fig=TRUE, width=6, height=8>>=
samples <- gsub(x = names(qc_intensities), pattern = "Intensity.\\d+_", replacement = "")
colors <- rainbow(length(samples))
maxY <- max(qc_intensities)/5
plotDensity(qc_intensities,
            xlim=c(0,maxY),
            col=colors, lwd=1,
            main="Distribution of untreated Signals (no transformation)",
            xlab="Quantitative value (x-axis is truncated)")
legend("topright", samples, text.col=colors)
@
  \caption{Density plot for quantifyable proteins (not transformed)}
  \label{fig:densityAsinh}
\end{figure}


\begin{figure}[!htb]
<<plotDensityASINHTransformation, echo=FALSE, fig=TRUE,  width=6, height=8>>=
plotDensity(asinh(qc_intensities), col=colors, lwd=1, main="Distributions of imputed signals before normalization", xlab="asinh(Quantvalue)")
legend("topright", samples, text.col=colors)
@
  \caption{Density plot of the quant values with imputation in asinh transformation (not yet normalized)}
  \label{fig:i_dens}
\end{figure}

\begin{figure}[!htb]
<<plotDensityNormalizedASINHTransformation, echo=FALSE, fig=TRUE,  width=6, height=8>>=
plotDensity(asinh(qc_normalized_intensities),
            col=colors, lwd=1,
            main="Signal Distributions (imputed and normalized)", xlab="asinh(Quantvalue)")
legend("topright", samples, text.col=colors)
@
  \caption{Density plot for normalized values based on imputed matrix (asinh)}
  \label{fig:normDensityPlot}
\end{figure}

The scaling factors are visualized in Figure \ref{fig:ScaleFactors}. It shows with what factor the individually calcuated numbers are boosted for the normalization.

\begin{figure}[!htb]
<<NormalizationFactors, echo=FALSE, fig=TRUE, width=12, height=8>>=
#scaleF <- read.table(sf, sep=" ", header=F)
#sf <- "appliedScaleFactors_Median.txt"
par(mfrow=c(1,1))
par(mar=c(4,10,4,1))
barplot(scaleF$V2, horiz=TRUE, names.arg=gsub(x = scaleF$V1, pattern = "Intensity.\\d+_", replacement = ""), cex.names = 1, las=1, main="Applied scaling Factors\n (for normalization)")
@
  \caption{Applied scaling factors for normalization (calculated using median normalization)}
  \label{fig:ScaleFactors}
\end{figure}





\begin{figure}[!htb]
<<CorrelationHeatmap, echo=FALSE, fig=TRUE, width=12, height=8>>=
heatmap.2(as.matrix(cor(asinh(qc_normalized_intensities))),margin=c(15,10),trace="none", main="Pairwise sample Correlation")
#SRMService:::DoCorrelationOnMatrix(asinh(n_i_dat))
@
  \caption{Correlation plot for normalized values based on imputed matrix (asinh)}
  \label{fig:normCorr}
\end{figure}



\begin{figure}[!htb]
<<pairsPlot, echo=FALSE, fig=TRUE, width=12, height=8>>=
pairs(asinh(qc_normalized_intensities), main="Pairwise Intensities vs Intensities Correlation", pch=".", col="blue")
@
  \caption{All Signals against all samples (hyperbolic arcsine transformation)}
  \label{fig:pairPlot}
\end{figure}


\pagebreak

\section{Disclaimer and Acknowledgements}
This report is written by J. Grossmann using the \href{https://github.com/protViz/SRMService}{SRMService} package version \Sexpr{packageVersion('SRMService')} and processes text files which are exported from MaxQuant.\\
\\
ALL INFORMATION, INTELLECTUAL PROPERTY RIGHTS, PRODUCTS AND / OR SERVICES ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY, SUITABILITY AND / OR FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN PARTICULAR, THE FGCZ (Functional Genomics Center Zurich, or any of its employees) MAKES NO WARRANTIES OF ANY KIND REGARDING THE ACCURACY OF ANY DATA, SOFTWARE, SCRIPTS AND / OR DATABASE.
\\
\\
Deep thanks go to C. Panse, S. Barkow, C. Trachsel, P. Nanni, C. Fortes and W. Wolski who provided stimulating environment, discussions and/or a template for this QC report.

\appendix

\section{Session information}
\label{section:session}
An overview of the package versions used to produce this document are
shown below.

<<sessioninfo, results=tex, echo=FALSE>>=
toLatex(sessionInfo())
@

\end{document}
